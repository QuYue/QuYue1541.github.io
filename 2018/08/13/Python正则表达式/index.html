<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      Python正则表达式 | 曲丘山の博客 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="Qu Yue">
    
    

    <meta name="description" content="曲岳 QuYue   1 Python正则表达式介绍   如果大家在工作中需要频繁的处理文本（或者称字符串），例如使用爬虫来爬取网页的信息，那么正则表达式一定会成为你最好的帮手。   正则表达式是一个十分强大的字符串处理工具，几乎任何关于字符串的操作都可以使用正则表达式来完成。当然正则表达式可以在许多门语言中使用，但是大同小异，几乎函数的功能都差不多（只不过换了个名字）。本文主要介绍Python中">
<meta name="keywords" content="编程技巧,Python,正则表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="Python正则表达式 | 曲丘山の博客">
<meta property="og:url" content="http://yoursite.com/2018/08/13/Python正则表达式/index.html">
<meta property="og:site_name" content="曲丘山の博客">
<meta property="og:description" content="曲岳 QuYue   1 Python正则表达式介绍   如果大家在工作中需要频繁的处理文本（或者称字符串），例如使用爬虫来爬取网页的信息，那么正则表达式一定会成为你最好的帮手。   正则表达式是一个十分强大的字符串处理工具，几乎任何关于字符串的操作都可以使用正则表达式来完成。当然正则表达式可以在许多门语言中使用，但是大同小异，几乎函数的功能都差不多（只不过换了个名字）。本文主要介绍Python中">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-11-28T08:25:22.348Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python正则表达式 | 曲丘山の博客">
<meta name="twitter:description" content="曲岳 QuYue   1 Python正则表达式介绍   如果大家在工作中需要频繁的处理文本（或者称字符串），例如使用爬虫来爬取网页的信息，那么正则表达式一定会成为你最好的帮手。   正则表达式是一个十分强大的字符串处理工具，几乎任何关于字符串的操作都可以使用正则表达式来完成。当然正则表达式可以在许多门语言中使用，但是大同小异，几乎函数的功能都差不多（只不过换了个名字）。本文主要介绍Python中">
    
    
    
      <link rel="icon" type="image/x-icon" href="/银八老师.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        
        <a href="/" title="link to homepage for 曲丘山の博客"><img src="/银八老师.png" width="80" alt="曲丘山の博客 logo" class="panel-cover__logo logo"></a>
        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">曲丘山の博客</a></h1>
        <hr class="panel-cover__divider">

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">Python正则表达式</h1>

    

    <div class="post-meta">
      <time datetime="2018-08-13" class="post-meta__date date">2018-08-13</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/Python/">Python</a>, <a class="tags-link" href="/tags/正则表达式/">正则表达式</a>, <a class="tags-link" href="/tags/编程技巧/">编程技巧</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <div align="right"><b><font face="楷体" size="4">曲岳 </font></b><i>QuYue</i></div>
<hr>
<h2 id="1-python正则表达式介绍"><a class="markdownIt-Anchor" href="#1-python正则表达式介绍"></a> 1 Python正则表达式介绍</h2>
<p>  如果大家在工作中需要频繁的处理文本（或者称字符串），例如使用爬虫来爬取网页的信息，那么正则表达式一定会成为你最好的帮手。<br>
  <strong>正则表达式是一个十分强大的字符串处理工具</strong>，几乎任何关于字符串的操作都可以使用正则表达式来完成。当然正则表达式可以在许多门语言中使用，但是大同小异，几乎函数的功能都差不多（只不过换了个名字）。本文主要介绍Python中正则表达式。<br>
  <strong>下面是一些基本介绍</strong>：</p>
<ol>
<li>在Python中几乎所有的正则表达式操作都需要调用一个模块，那就是强大的re模块，是Python的一个标准库。</li>
<li>使用反斜杠<code>\</code>来对特殊字符进行转义。</li>
<li>不过最好使用<code>'r'</code>来直接使用原生字符串表示法（raw string notation）。</li>
</ol>
<p>  在网上有许多相关的详细教程，最详细的是<a href="https://docs.python.org/3/library/re.html" title="官方教程">Python的re模块官方教程</a>，当然也其他的一些教程，例如<a href="https://www.cnblogs.com/dyfblog/p/5880728.html" title="正则表达式详解">正则表达式详解</a>等。本文是在这些教程的基础上进行整合，提取出最为实用的一些使用方法。</p>
<h2 id="2-元字符"><a class="markdownIt-Anchor" href="#2-元字符"></a> 2 元字符</h2>
<p>  对与正则表达式来说包含了特殊字符和普通字符，多数的普通字符（例如<code>'A','a','0'</code>）就是一个最简单的正则表达式。它们可以匹配自身。当然，我们可以将这些字符串联起来，来匹配单词等。而一些特殊的字符会代替一类的普通的字符，或者对其周围的解释方法进行影响。<br>
  首先介绍一下元字符：</p>
<table>
<thead>
<tr>
<th style="text-align:left">character</th>
<th style="text-align:left">mean</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">匹配任意字符（不包括换行符)</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">匹配开始位置，多行模式下匹配每一行的开始</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">匹配结束位置，多行模式下匹配每一行的结束</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配前一个元字符0到多次</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">匹配前一个元字符1到多次</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配前一个元字符0到1次</td>
</tr>
<tr>
<td style="text-align:left">{m,n}</td>
<td style="text-align:left">匹配前一个元字符m到n次</td>
</tr>
<tr>
<td style="text-align:left">\\</td>
<td style="text-align:left">转义字符，跟在其后的字符将失去作为特殊元字符的含义，例如<code>\\</code>.只能匹配.，不能再匹配任意字符</td>
</tr>
<tr>
<td style="text-align:left">[]</td>
<td style="text-align:left">字符集，一个字符的集合，可匹配其中任意一个字符</td>
</tr>
<tr>
<td style="text-align:left">|</td>
<td style="text-align:left">逻辑表达式：或（比如<code>a|b</code>代表可以匹配<code>a</code>或<code>b</code>）</td>
</tr>
<tr>
<td style="text-align:left">(…)</td>
<td style="text-align:left">分组，默认为捕获，即被分组的内容可以被单独取出，默认每个分组有个索引，从 1 开始，按照&quot;(&quot;的顺序决定索引值</td>
</tr>
<tr>
<td style="text-align:left">(?iLmsux)</td>
<td style="text-align:left">分组中可以设置模式，iLmsux之中的每个字符代表一个模式,用法参见3.1 模式I</td>
</tr>
<tr>
<td style="text-align:left">(?:…)</td>
<td style="text-align:left">分组的不捕获模式，计算索引时会跳过这个分组</td>
</tr>
<tr>
<td style="text-align:left">(?P<name>…)</name></td>
<td style="text-align:left">分组的命名模式，取此分组中的内容时可以使用索引也可以使用name</td>
</tr>
<tr>
<td style="text-align:left">(?P=name)</td>
<td style="text-align:left">分组的引用模式，可在同一个正则表达式用引用前面命名过的正则</td>
</tr>
<tr>
<td style="text-align:left">(?#…)</td>
<td style="text-align:left">注释，不影响正则表达式其它部分,参见3.1 模式I</td>
</tr>
<tr>
<td style="text-align:left">(?=…)</td>
<td style="text-align:left">顺序肯定环视，表示所在位置右侧能够匹配括号内正则</td>
</tr>
<tr>
<td style="text-align:left">(?!..)</td>
<td style="text-align:left">顺序否定环视，表示所在位置右侧不能匹配括号内正则</td>
</tr>
<tr>
<td style="text-align:left">(?&lt;=…)</td>
<td style="text-align:left">逆序肯定环视，表示所在位置左侧能够匹配括号内正则</td>
</tr>
<tr>
<td style="text-align:left">(?&lt;!..)</td>
<td style="text-align:left">逆序否定环视，表示所在位置左侧不能匹配括号内正则</td>
</tr>
<tr>
<td style="text-align:left">(?(id/name)yes|no)</td>
<td style="text-align:left">若前面指定id或name的分区匹配成功则执行yes处的正则，否则执行no处的正则</td>
</tr>
<tr>
<td style="text-align:left">\number</td>
<td style="text-align:left">匹配和前面索引为number的分组捕获到的内容一样的字符串</td>
</tr>
<tr>
<td style="text-align:left">\A</td>
<td style="text-align:left">匹配字符串开始位置，忽略多行模式</td>
</tr>
<tr>
<td style="text-align:left">\Z</td>
<td style="text-align:left">匹配字符串结束位置，忽略多行模式</td>
</tr>
<tr>
<td style="text-align:left">\b</td>
<td style="text-align:left">匹配位于单词开始或结束位置的空字符串</td>
</tr>
<tr>
<td style="text-align:left">\B</td>
<td style="text-align:left">匹配不位于单词开始或结束位置的空字符串</td>
</tr>
<tr>
<td style="text-align:left">\d</td>
<td style="text-align:left">匹配一个数字， 相当于 [0-9]</td>
</tr>
<tr>
<td style="text-align:left">\D</td>
<td style="text-align:left">匹配非数字,相当于 [^0-9]</td>
</tr>
<tr>
<td style="text-align:left">\s</td>
<td style="text-align:left">匹配任意空白字符， 相当于 [ \t\n\r\f\v]</td>
</tr>
<tr>
<td style="text-align:left">\S</td>
<td style="text-align:left">匹配非空白字符， 相当于 [^ \t\n\r\f\v]</td>
</tr>
<tr>
<td style="text-align:left">\w</td>
<td style="text-align:left">匹配数字、字母、下划线中的任意字符，相当于 [a-zA-Z0-9_]</td>
</tr>
<tr>
<td style="text-align:left">\W</td>
<td style="text-align:left">匹配非数字、字母、下划线中的任意字符，相当于 [^a-zA-Z0-9_]</td>
</tr>
</tbody>
</table>
<h2 id="3-模式"><a class="markdownIt-Anchor" href="#3-模式"></a> 3 模式</h2>
<h3 id="31-模式-i"><a class="markdownIt-Anchor" href="#31-模式-i"></a> 3.1 模式 I</h3>
<p>  I模式（IGNORECASE），即忽略大小写的匹配模式, 样例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s = <span class="string">'hello World!'</span></span><br><span class="line"></span><br><span class="line">regex = re.compile(<span class="string">"hello world!"</span>, re.I)</span><br><span class="line">print(regex.match(s).group())</span><br><span class="line"><span class="comment">#output&gt; 'Hello World!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在正则表达式中指定模式以及注释</span></span><br><span class="line">regex = re.compile(<span class="string">"(?#注释)(?i)hello world!"</span>)</span><br><span class="line">print(regex.match(s).group())</span><br><span class="line"><span class="comment">#output&gt; 'Hello World!'</span></span><br></pre></td></tr></table></figure>
<h3 id="32-模式-l"><a class="markdownIt-Anchor" href="#32-模式-l"></a> 3.2 模式 L</h3>
<p>  L模式（LOCALE），字符集本地化。这个功能是为了支持的多语言版本的字符集使用环境的，比如在转义符<code>\w</code>，在英文环境下，代表[a-zA-Z0-9_]（所有的数字、字母、下划线），如果在一个法语环境下使用，缺省设置下，不能匹配<code>&quot;é&quot;</code> 或<code>&quot;ç&quot;</code>。加上这L选项和就可以匹配了。不过这个对于中文环境似乎没有什么用，它仍然不能匹配中文字符。</p>
<h3 id="33-模式-m"><a class="markdownIt-Anchor" href="#33-模式-m"></a> 3.3 模式 M</h3>
<p>  M模式（MULTILINE），多行模式，改变<code>^</code>和<code>$</code>的行为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''first line</span></span><br><span class="line"><span class="string">second line</span></span><br><span class="line"><span class="string">third line'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ^</span></span><br><span class="line">regex_start = re.compile(<span class="string">"^\w+"</span>)</span><br><span class="line">print(regex_start.findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['first']</span></span><br><span class="line"></span><br><span class="line">regex_start_m = re.compile(<span class="string">"^\w+"</span>, re.M)</span><br><span class="line">print(regex_start_m.findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['first', 'second', 'third']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#$</span></span><br><span class="line">regex_end = re.compile(<span class="string">"\w+$"</span>)</span><br><span class="line">print(regex_end.findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['line']</span></span><br><span class="line"></span><br><span class="line">regex_end_m = re.compile(<span class="string">"\w+$"</span>, re.M)</span><br><span class="line">print(regex_end_m.findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['line', 'line', 'line']</span></span><br></pre></td></tr></table></figure>
<h3 id="34-模式-s"><a class="markdownIt-Anchor" href="#34-模式-s"></a> 3.4 模式 S</h3>
<p>  S模式（DOTALL），此模式下<code>'.'</code>的匹配不受限制，可匹配任何字符，包括换行符</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''first line</span></span><br><span class="line"><span class="string">second line</span></span><br><span class="line"><span class="string">third line'''</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">regex = re.compile(<span class="string">".+"</span>)</span><br><span class="line">print(regex.findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['first line', 'second line', 'third line']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.S</span></span><br><span class="line">regex_dotall = re.compile(<span class="string">".+"</span>, re.S)</span><br><span class="line">print(regex_dotall.findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['first line\nsecond line\nthird line']</span></span><br></pre></td></tr></table></figure>
<h3 id="35-模式-x"><a class="markdownIt-Anchor" href="#35-模式-x"></a> 3.5 模式 X</h3>
<p>  X模式（VERBOSE），冗余模式，此模式忽略正则表达式中的空白和#号的注视，例如写一个匹配邮箱的正则表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">email_regex = re.compile(<span class="string">"[\w+\.]+@[a-zA-Z\d]+\.(com|cn)"</span>)</span><br><span class="line"><span class="comment"># 可以写成</span></span><br><span class="line">email_regex = re.compile(<span class="string">"""[\w+\.]+  # 匹配@符前的部分</span></span><br><span class="line"><span class="string">                            @  # @符</span></span><br><span class="line"><span class="string">                            [a-zA-Z\d]+  # 邮箱类别</span></span><br><span class="line"><span class="string">                            \.(com|cn)   # 邮箱后缀  """</span>, re.X)</span><br></pre></td></tr></table></figure>
<h3 id="36-模式-u"><a class="markdownIt-Anchor" href="#36-模式-u"></a> 3.6 模式 U</h3>
<p>  U模式（UNICODE），使用\w,\W,\b,\B这些元字符时将按照UNICODE定义的属性。</p>
<h3 id="37-其他"><a class="markdownIt-Anchor" href="#37-其他"></a> 3.7 其他</h3>
<p>  正则表达式的模式是可以同时使用多个的，在Python里面使用按位或运算符<code>|</code>同时添加多个模式，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(<span class="string">''</span>, re.I|re.M|re.S)</span><br></pre></td></tr></table></figure>
<h2 id="4-函数"><a class="markdownIt-Anchor" href="#4-函数"></a> 4 函数</h2>
<p>  Python的re模块有许多方便的函数来使用正则表达式来操作字符。这些函数需要 我们熟练掌握。</p>
<ul>
<li>
<p>compile(pattern, flags=0)<br>
输入：正则表达式pattern，模式 flags(默认0，即不使用任何模式)。<br>
输出：SRE_Pattern对象。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex = re.compile(<span class="string">".+"</span>)</span><br><span class="line">print(type(regex))</span><br><span class="line"><span class="comment"># output&gt; &lt;_sre.SRE_Pattern object at 0x00000000026BB0B8&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个对象可以调用其他函数来完成匹配，一般来说推荐使用 compile 函数预编译出一个正则模式之后再去使用，这样在后面的代码中可以很方便的复用它，当然大部分函数也可以不用 compile 直接使用，具体见 findall 函数。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''first line</span></span><br><span class="line"><span class="string">second line</span></span><br><span class="line"><span class="string">third line'''</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">regex = re.compile(<span class="string">".+"</span>)</span><br><span class="line"><span class="comment"># 调用 findall 函数</span></span><br><span class="line">print(regex.findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['first line', 'second line', 'third line']</span></span><br><span class="line"><span class="comment"># 调用 search 函数</span></span><br><span class="line">print(regex.search(s).group())</span><br><span class="line"><span class="comment"># output&gt; first lin</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>escape(pattern)<br>
输入：正则表达式pattern。<br>
输出：转义的正则表达式。<br>
转义，如果文本中含有正则的元子符，你在写正则的时候需要使用转义的<code>\</code>来进行匹配，当存在很多的时候会显得比较乱。这时便可以使用这个函数将其转义。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">".+\d123"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">regex_str = re.escape(<span class="string">".+\d123"</span>)</span><br><span class="line"><span class="comment"># 查看转义后的字符</span></span><br><span class="line"><span class="keyword">print</span> regex_str</span><br><span class="line"><span class="comment"># output&gt; \.\+\\d123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看匹配到的结果</span></span><br><span class="line"><span class="keyword">for</span> g <span class="keyword">in</span> re.findall(regex_str, s):</span><br><span class="line">    <span class="keyword">print</span> g</span><br><span class="line"><span class="comment"># output&gt; .+\d123</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>findall(pattern, string, flags=0)<br>
输入：正则表达式pattern，待操作的字符串string，模式flags(默认0)。<br>
输出：返回一个list（string中所有匹配的正则表达式的子串），如果没有匹配到任何子串，返回一个空列表。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''first line</span></span><br><span class="line"><span class="string">second line</span></span><br><span class="line"><span class="string">third line'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compile 预编译后使用 findall</span></span><br><span class="line">regex = re.compile(<span class="string">"\w+"</span>)</span><br><span class="line">print(regex.findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['first', 'line', 'second', 'line', 'third', 'line']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用 compile 直接使用 findall</span></span><br><span class="line">print(re.findall(<span class="string">"\w+"</span>, s))</span><br><span class="line"><span class="comment"># output&gt; ['first', 'line', 'second', 'line', 'third', 'line']</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>finditer(pattern, string, flags=0)<br>
输入：正则表达式pattern，待操作的字符串string，模式flags(默认0)。<br>
输出：返回一个迭代器（每次迭代返回的是SRE_Match）。<br>
作用同findall，但是返回迭代器，且返回SRE_Match对象。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''first line</span></span><br><span class="line"><span class="string">second line</span></span><br><span class="line"><span class="string">third line'''</span></span><br><span class="line"></span><br><span class="line">regex = re.compile(<span class="string">"\w+"</span>)</span><br><span class="line">print(regex.finditer(s))</span><br><span class="line"><span class="comment"># output&gt; &lt;callable-iterator object at 0x0000000001DF3B38&gt;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> regex.finditer(s):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment"># output&gt; &lt;_sre.SRE_Match object at 0x0000000002B7A920&gt;</span></span><br><span class="line"><span class="comment">#         &lt;_sre.SRE_Match object at 0x0000000002B7A8B8&gt;</span></span><br><span class="line"><span class="comment">#         &lt;_sre.SRE_Match object at 0x0000000002B7A920&gt;</span></span><br><span class="line"><span class="comment">#         &lt;_sre.SRE_Match object at 0x0000000002B7A8B8&gt;</span></span><br><span class="line"><span class="comment">#         &lt;_sre.SRE_Match object at 0x0000000002B7A920&gt;</span></span><br><span class="line"><span class="comment">#         &lt;_sre.SRE_Match object at 0x0000000002B7A8B8&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>match(pattern, string, flags=0)<br>
输入：正则表达式pattern，待操作的字符串string，模式flags(默认0)。<br>
输出：返回一个SRE_Match对象。<br>
使用指定正则去待操作字符串中寻找可以匹配的子串，返回匹配上第一个字串，并且不再继续找，需要注意的是match函数是从字符串开始处开始查找的，如果开始处不匹配，则不再继续。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''first line</span></span><br><span class="line"><span class="string">second line</span></span><br><span class="line"><span class="string">third line'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compile</span></span><br><span class="line">regex = re.compile(<span class="string">"\w+"</span>)</span><br><span class="line">m = regex.match(s)</span><br><span class="line">print(m)</span><br><span class="line"><span class="comment"># output&gt; &lt;_sre.SRE_Match object at 0x0000000002BCA8B8&gt;</span></span><br><span class="line">print(m.group())</span><br><span class="line"><span class="comment"># output&gt; first</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s 的开头是 "f", 但正则中限制了开始为 i 所以找不到</span></span><br><span class="line">regex = re.compile(<span class="string">"^i\w+"</span>)</span><br><span class="line">print(regex.match(s))</span><br><span class="line"><span class="comment"># output&gt; None</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>purge()<br>
当你在程序中使用 re 模块，无论是先使用 compile 还是直接使用比如 findall 来使用正则表达式操作文本，re 模块都会将正则表达式先编译一下， 并且会将编译过后的正则表达式放到缓存中，这样下次使用同样的正则表达式的时候就不需要再次编译， 因为编译其实是很费时的，这样可以提升效率，而默认缓存的正则表达式的个数是 100, 当你需要频繁使用少量正则表达式的时候，缓存可以提升效率，而使用的正则表达式过多时，缓存带来的优势就不明显了。此函数是清除缓存中的正则表达式（优化内存）。</p>
</li>
<li>
<p>search(pattern, string, flags=0)<br>
输入：正则表达式pattern，待操作的字符串string，模式flags(默认0)。<br>
输出：返回一个SRE_Match对象。<br>
类似match，但不限制正则表达式的开始匹配位置。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''first line</span></span><br><span class="line"><span class="string">second line</span></span><br><span class="line"><span class="string">third line'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要从开始处匹配 所以匹配不到 </span></span><br><span class="line">print(re.match(<span class="string">'i\w+'</span>, s))</span><br><span class="line"><span class="comment"># output&gt; None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有限制起始匹配位置</span></span><br><span class="line">print(re.search(<span class="string">'i\w+'</span>, s))</span><br><span class="line"><span class="comment"># output&gt; &lt;_sre.SRE_Match object at 0x0000000002C6A920&gt;</span></span><br><span class="line"></span><br><span class="line">print(re.search(<span class="string">'i\w+'</span>, s).group())</span><br><span class="line"><span class="comment"># output&gt; irst</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>split(pattern, string, maxsplit=0, flags=0)<br>
输入：正则表达式pattern，待操作的字符串string，切分次数maxsplit(默认0)，模式flags(默认0)。<br>
输出：返回一个切分后子串的list，如果匹配不到，则返回一个list（list中是原字符串）。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'''first 111 line</span></span><br><span class="line"><span class="string">second 222 line</span></span><br><span class="line"><span class="string">third 333 line'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照数字切分</span></span><br><span class="line">print(re.split(<span class="string">'\d+'</span>, s))</span><br><span class="line"><span class="comment"># output&gt; ['first ', ' line\nsecond ', ' line\nthird ', ' line']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># \.+ 匹配不到 返回包含自身的列表</span></span><br><span class="line">print(re.split(<span class="string">'\.+'</span>, s, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># output&gt; ['first 111 line\nsecond 222 line\nthird 333 line']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># maxsplit 参数</span></span><br><span class="line">print(re.split(<span class="string">'\d+'</span>, s, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># output&gt; ['first ', ' line\nsecond 222 line\nthird 333 line']</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>sub(pattern, repl, string, count=0, flags=0)<br>
输入：正则表达式pattern，替换的字符串repl，待操作的字符串string，最大替换次数count(默认0)，模式flags(默认0)。<br>
输出：返回一个将正则表达式匹配到的字符串被替换成repl的字符串。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"the sum of 7 and 9 is [7+9]."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本用法 将目标替换为固定字符串</span></span><br><span class="line"><span class="keyword">print</span> re.sub(<span class="string">'\[7\+9\]'</span>, <span class="string">'16'</span>, s)</span><br><span class="line"><span class="comment"># output&gt; the sum of 7 and 9 is 16.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级用法 1 使用前面匹配的到的内容 \1 代表 pattern 中捕获到的第一个分组的内容</span></span><br><span class="line"><span class="keyword">print</span> re.sub(<span class="string">'\[(7)\+(9)\]'</span>, <span class="string">r'\2\1'</span>, s)</span><br><span class="line"><span class="comment"># output&gt; the sum of 7 and 9 is 97.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级用法 2 使用函数型 repl 参数, 处理匹配到的 SRE_Match 对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replacement</span><span class="params">(m)</span>:</span></span><br><span class="line">    p_str = m.group()</span><br><span class="line">    <span class="keyword">if</span> p_str == <span class="string">'7'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'77'</span></span><br><span class="line">    <span class="keyword">if</span> p_str == <span class="string">'9'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'99'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"><span class="keyword">print</span> re.sub(<span class="string">'\d'</span>, replacement, s)</span><br><span class="line"><span class="comment"># output&gt; the sum of 77 and 99 is [77+99].</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级用法 3 使用函数型 repl 参数, 处理匹配到的 SRE_Match 对象 增加作用域 自动计算</span></span><br><span class="line">scope = &#123;&#125;</span><br><span class="line">example_string_1 = <span class="string">"the sum of 7 and 9 is [7+9]."</span></span><br><span class="line">example_string_2 = <span class="string">"[name = 'Mr.Gumby']Hello,[name]"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replacement</span><span class="params">(m)</span>:</span></span><br><span class="line">    code = m.group(<span class="number">1</span>)</span><br><span class="line">    st = <span class="string">''</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        st = str(eval(code, scope))</span><br><span class="line">    <span class="keyword">except</span> SyntaxError:</span><br><span class="line">        <span class="keyword">exec</span> code <span class="keyword">in</span> scope</span><br><span class="line">    <span class="keyword">return</span> st</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析: code='7+9'</span></span><br><span class="line"><span class="comment">#       str(eval(code, scope))='16'</span></span><br><span class="line"><span class="keyword">print</span> re.sub(<span class="string">'\[(.+?)\]'</span>, replacement, example_string_1)</span><br><span class="line"><span class="comment"># output&gt; the sum of 7 and 9 is 16.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两次替换</span></span><br><span class="line"><span class="comment"># 解析1: code="name = 'Mr.Gumby'"</span></span><br><span class="line"><span class="comment">#       eval(code)</span></span><br><span class="line"><span class="comment">#       raise SyntaxError</span></span><br><span class="line"><span class="comment">#       exec code in scope</span></span><br><span class="line"><span class="comment">#       在命名空间 scope 中将 "Mr.Gumby" 赋给了变量 name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析2: code="name"</span></span><br><span class="line"><span class="comment">#       eval(name) 返回变量 name 的值 Mr.Gumby</span></span><br><span class="line"><span class="keyword">print</span> re.sub(<span class="string">'\[(.+?)\]'</span>, replacement, example_string_2)</span><br><span class="line"><span class="comment"># output&gt; Hello,Mr.Gumby</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>subn(pattern, repl, string, count=0, flags=0)<br>
输入：正则表达式pattern，替换的字符串repl，待操作的字符串string，最大替换次数count(默认0)，模式flags(默认0)。<br>
输出：返回一个元组，第一个值是将正则表达式匹配到的字符串被替换成repl的字符串；第二个值是发生替换的次数。（整体同sub）</p>
</li>
<li>
<p>template(pattern, flags=0)<br>
这个吧，咋一看和 compile 差不多，不过不支持 +、？、*、｛｝ 等这样的元字符，只要是需要有重复功能的元字符，就不支持，查了查资料，貌似没人知道这个函数到底是干嘛的…</p>
</li>
</ul>
<h2 id="5-内置对象"><a class="markdownIt-Anchor" href="#5-内置对象"></a> 5 内置对象</h2>
<ul>
<li>
<p>SRE_Pattern:此对象是编译后的正则表达式，编译后可以复用、提升效率、也能获取一些其他的关于正则表达式的信息（如下所示）。<br>
属性：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>means</th>
</tr>
</thead>
<tbody>
<tr>
<td>flags</td>
<td>编译时指定的模式</td>
</tr>
<tr>
<td>groupindex</td>
<td>以正则表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内</td>
</tr>
<tr>
<td>groups</td>
<td>正则表达式中分组的数量</td>
</tr>
<tr>
<td>pattern</td>
<td>编译时用的正则表达式</td>
</tr>
</tbody>
</table>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello, Mr.Gumby : 2016/10/26'</span></span><br><span class="line">p = re.compile(<span class="string">'''(?:        # 构造一个不捕获分组 用于使用 |</span></span><br><span class="line"><span class="string">            (?P&lt;name&gt;\w+\.\w+)    # 匹配 Mr.Gumby</span></span><br><span class="line"><span class="string">            |     # 或</span></span><br><span class="line"><span class="string">            (?P&lt;no&gt;\s+\.\w+) # 一个匹配不到的命名分组</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">            .*? # 匹配  : </span></span><br><span class="line"><span class="string">            (\d+) # 匹配 2016</span></span><br><span class="line"><span class="string">            '''</span>, re.X)</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">print</span> p.flags</span><br><span class="line"><span class="comment"># output&gt; 64</span></span><br><span class="line"><span class="keyword">print</span> p.groupindex</span><br><span class="line"><span class="comment"># output&gt; &#123;'name': 1, 'no': 2&#125;</span></span><br><span class="line"><span class="keyword">print</span> p.groups</span><br><span class="line"><span class="comment"># output&gt; 3</span></span><br><span class="line"><span class="keyword">print</span> p.pattern</span><br><span class="line"><span class="comment"># output&gt; (?:        # 构造一个不捕获分组 用于使用 |</span></span><br><span class="line"><span class="comment">#              (?P&lt;name&gt;\w+\.\w+)    # 匹配 Mr.Gumby</span></span><br><span class="line"><span class="comment">#              |     # 或</span></span><br><span class="line"><span class="comment">#              (?P&lt;no&gt;\s+\.\w+) # 一个匹配不到的命名分组</span></span><br><span class="line"><span class="comment">#              )</span></span><br><span class="line"><span class="comment">#              .*? # 匹配  : </span></span><br><span class="line"><span class="comment">#              (\d+) # 匹配 2016</span></span><br></pre></td></tr></table></figure>
<p>函数：可使用 findall、finditer、match、search、split、sub、subn 等函数</p>
</li>
<li>
<p>SRE_Match:这个对相对保存本次匹配的结果，包含很多关于匹配过称以及匹配结果的信息。<br>
属性：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>means</th>
</tr>
</thead>
<tbody>
<tr>
<td>endpos</td>
<td>本次搜索结束位置索引</td>
</tr>
<tr>
<td>lastgroup</td>
<td>本次搜索匹配到的最后一个分组的别名</td>
</tr>
<tr>
<td>lastindex</td>
<td>本次搜索匹配到的最后一个分组的索引</td>
</tr>
<tr>
<td>pos</td>
<td>本次搜索开始位置索引</td>
</tr>
<tr>
<td>re</td>
<td>本次搜索使用的 SRE_Pattern 对象</td>
</tr>
<tr>
<td>regs</td>
<td>列表，元素为元组，包含本次搜索匹配到的所有分组的起止位置</td>
</tr>
<tr>
<td>string</td>
<td>本次搜索操作的字符串</td>
</tr>
</tbody>
</table>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello, Mr.Gumby : 2016/10/26'</span></span><br><span class="line">m = re.search(<span class="string">', (?P&lt;name&gt;\w+\.\w+).*?(\d+)'</span>, s)</span><br><span class="line"><span class="comment"># 本次搜索的结束位置索引</span></span><br><span class="line">print(m.endpos)</span><br><span class="line"><span class="comment"># output&gt; 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本次搜索匹配到的最后一个分组的别名</span></span><br><span class="line"><span class="comment"># 本次匹配最后一个分组没有别名</span></span><br><span class="line">print(m.lastgroup)</span><br><span class="line"><span class="comment"># output&gt; None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本次搜索匹配到的最后一个分组的索引</span></span><br><span class="line">print(m.lastindex)</span><br><span class="line"><span class="comment"># output&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本次搜索开始位置索引</span></span><br><span class="line">print(m.pos)</span><br><span class="line"><span class="comment"># output&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本次搜索使用的 SRE_Pattern 对象</span></span><br><span class="line">print(m.re)</span><br><span class="line"><span class="comment"># output&gt; &lt;_sre.SRE_Pattern object at 0x000000000277E158&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表，元素为元组，包含本次搜索匹配到的所有分组的起止位置 第一个元组为正则表达式匹配范围</span></span><br><span class="line">print(m.regs)</span><br><span class="line"><span class="comment"># output&gt; ((7, 22), (7, 15), (18, 22))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 本次搜索操作的字符串</span></span><br><span class="line">print(m.string)</span><br><span class="line"><span class="comment"># output&gt; Hello, Mr.Gumby : 2016/10/26</span></span><br></pre></td></tr></table></figure>
<p>函数：</p>
<ul>
<li>end([group=0]) 返回指定分组的结束位置，默认返回<strong>正则表达式所匹配到的最后一个字符的索引</strong></li>
<li>expand(template) 根据模版返回相应的字符串，类似与sub函数里面的repl，可使用\1或者\g<name>来选择分组</name></li>
<li>group([group1, …]) 根据提供的索引或名字返回响应分组的内容，默认返回 start() 到 end() 之间的字符串， 提供多个参数将返回一个元组</li>
<li>groupdict([default=None]) 返回 返回一个包含所有匹配到的命名分组的字典，没有命名的分组不包含在内，key为组名，value为匹配到的内容，参数default为没有参与本次匹配的命名分组提供默认值</li>
<li>groups([default=None])以元组形式返回每一个分组匹配到的字符串，包括没有参与匹配的分组，其值为default</li>
<li>span([group]) 返回指定分组的起止位置组成的元组，默认返回由start()和end()组成的元组</li>
<li>start([group]) 返回指定分组的开始位置，默认返回<strong>正则表达式所匹配到的第一个字符的索引</strong></li>
</ul>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello, Mr.Gumby : 2016/10/26'</span></span><br><span class="line">m = re.search(<span class="string">'''(?:        # 构造一个不捕获分组 用于使用 |</span></span><br><span class="line"><span class="string">            (?P&lt;name&gt;\w+\.\w+)    # 匹配 Mr.Gumby</span></span><br><span class="line"><span class="string">            |     # 或</span></span><br><span class="line"><span class="string">            (?P&lt;no&gt;\s+\.\w+) # 一个匹配不到的命名分组</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string">            .*? # 匹配  : </span></span><br><span class="line"><span class="string">            (\d+) # 匹配 2016</span></span><br><span class="line"><span class="string">            '''</span>,</span><br><span class="line">            s, re.X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定分组的结束位置，默认返回正则表达式所匹配到的最后一个字符的索引</span></span><br><span class="line">print(m.end())</span><br><span class="line"><span class="comment"># output&gt; 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据模版返回相应的字符串，类似与 sub 函数里面的 repl， 可使用 \1 或者 \g&lt;name&gt; 来选择分组</span></span><br><span class="line">print(m.expand(<span class="string">"my name is \\1"</span>))</span><br><span class="line"><span class="comment"># output&gt; my name is Mr.Gumby</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据提供的索引或名字返回响应分组的内容，默认返回 start() 到 end() 之间的字符串， 提供多个参数将返回一个元组</span></span><br><span class="line">print(m.group())</span><br><span class="line"><span class="comment"># output&gt; Mr.Gumby : 2016</span></span><br><span class="line">print(m.group(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># output&gt; ('Mr.Gumby', None)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 返回一个包含所有匹配到的命名分组的字典，没有命名的分组不包含在内，key 为组名， value 为匹配到的内容，参数 default 为没有参与本次匹配的命名分组提供默认值</span></span><br><span class="line">print(m.groupdict(<span class="string">'default_string'</span>))</span><br><span class="line"><span class="comment"># output&gt; &#123;'name': 'Mr.Gumby', 'no': 'default_string'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组形式返回每一个分组匹配到的字符串，包括没有参与匹配的分组，其值为 default</span></span><br><span class="line">print(m.groups(<span class="string">'default_string'</span>))</span><br><span class="line"><span class="comment"># output&gt; ('Mr.Gumby', 'default_string', '2016')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定分组的起止未知组成的元组，默认返回由 start() 和 end() 组成的元组</span></span><br><span class="line">print(m.span(<span class="number">3</span>))</span><br><span class="line"><span class="comment"># output&gt; (18, 22)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定分组的开始位置，默认返回正则表达式所匹配到的第一个字符的索引</span></span><br><span class="line">print(m.start(<span class="number">3</span>))</span><br><span class="line"><span class="comment"># output&gt; 18</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-分组用法"><a class="markdownIt-Anchor" href="#6-分组用法"></a> 6 分组用法</h2>
<p>  python 的正则表达式中用小括号 “(” 表示分组，按照每个分组中前半部分出现的顺序 “(” 判定分组的索引，索引从 1 开始，每个分组在访问的时候可以使用索引，也可以使用别名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello, Mr.Gumby : 2016/10/26'</span></span><br><span class="line">p = re.compile(<span class="string">"(?P&lt;name&gt;\w+\.\w+).*?(\d+)(?#comment)"</span>)</span><br><span class="line">m = p.search(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用别名访问</span></span><br><span class="line">print(m.group(<span class="string">'name'</span>))</span><br><span class="line"><span class="comment"># output&gt; Mr.Gumby</span></span><br><span class="line"><span class="comment"># 使用分组访问</span></span><br><span class="line">print(m.group(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># output&gt; 2016</span></span><br></pre></td></tr></table></figure>
<p>  有时候可能只是为了把正则表达式分组，而不需要捕获其中的内容，这时候可以使用非捕获分组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello, Mr.Gumby : 2016/10/26'</span></span><br><span class="line">p = re.compile(<span class="string">"""</span></span><br><span class="line"><span class="string">                (?:  # 非捕获分组标志 用于使用 |</span></span><br><span class="line"><span class="string">                    (?P&lt;name&gt;\w+\.\w+)</span></span><br><span class="line"><span class="string">                    |</span></span><br><span class="line"><span class="string">                    (\d+/)</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">                """</span>, re.X)</span><br><span class="line">m = p.search(s)</span><br><span class="line"><span class="comment"># 使用非捕获分组</span></span><br><span class="line"><span class="comment"># 此分组将不计入 SRE_Pattern 的 分组计数</span></span><br><span class="line">print(p.groups)</span><br><span class="line"><span class="comment"># output&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不计入 SRE_Match 的分组</span></span><br><span class="line">print(m.groups())</span><br><span class="line"><span class="comment"># output&gt; ('Mr.Gumby', None)</span></span><br></pre></td></tr></table></figure>
<p>  如果你在写正则的时候需要在正则里面重复书写某个表达式，那么你可以使用正则的引用分组功能，需要注意的是引用的不是前面分组的 正则表达式 而是捕获到的 内容，并且引用的分组不算在分组总数中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello, Mr.Gumby : 2016/2016/26'</span></span><br><span class="line">p = re.compile(<span class="string">"""</span></span><br><span class="line"><span class="string">                (?:  # 非捕获分组标志 用于使用 |</span></span><br><span class="line"><span class="string">                    (?P&lt;name&gt;\w+\.\w+)</span></span><br><span class="line"><span class="string">                    |</span></span><br><span class="line"><span class="string">                    (\d+/)</span></span><br><span class="line"><span class="string">                )</span></span><br><span class="line"><span class="string">                .*?(?P&lt;number&gt;\d+)/(?P=number)/</span></span><br><span class="line"><span class="string">                """</span>, re.X)</span><br><span class="line">m = p.search(s)</span><br><span class="line"><span class="comment"># 使用引用分组</span></span><br><span class="line"><span class="comment"># 此分组将不计入 SRE_Pattern 的 分组计数</span></span><br><span class="line"><span class="keyword">print</span> p.groups</span><br><span class="line"><span class="comment"># output&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不计入 SRE_Match 的分组</span></span><br><span class="line"><span class="keyword">print</span> m.groups()</span><br><span class="line"><span class="comment"># output&gt; ('Mr.Gumby', None, '2016')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看匹配到的字符串</span></span><br><span class="line"><span class="keyword">print</span> m.group()</span><br><span class="line"><span class="comment"># output&gt; Mr.Gumby : 2016/2016/</span></span><br></pre></td></tr></table></figure>
<h2 id="7-环视用法"><a class="markdownIt-Anchor" href="#7-环视用法"></a> 7 环视用法</h2>
<p>  环视还有其他的名字，例如界定、断言、预搜索等。<br>
  环视是一种特殊的正则语法，它匹配的不是字符串，而是 位置，其实就是使用正则来说明这个位置的左右应该是什么或者应该不是什么，然后去寻找这个位置。<br>
  环视的语法有四种，具体见元字符，基本用法如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Hello, Mr.Gumby : 2016/10/26  Hello,r.Gumby : 2016/10/26'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不加环视限定</span></span><br><span class="line">print(re.compile(<span class="string">"(?P&lt;name&gt;\w+\.\w+)"</span>).findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['Mr.Gumby', 'r.Gumby']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环视表达式所在位置 左边为 "Hello, "</span></span><br><span class="line">print(re.compile(<span class="string">"(?&lt;=Hello, )(?P&lt;name&gt;\w+\.\w+)"</span>).findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['Mr.Gumby']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环视表达式所在位置 左边不为 ","</span></span><br><span class="line">print(re.compile(<span class="string">"(?&lt;!,)(?P&lt;name&gt;\w+\.\w+)"</span>).findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['Mr.Gumby']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环视表达式所在位置 右边为 "M"</span></span><br><span class="line">print(re.compile(<span class="string">"(?=M)(?P&lt;name&gt;\w+\.\w+)"</span>).findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['Mr.Gumby']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 环视表达式所在位置 右边不为 r</span></span><br><span class="line">print(re.compile(<span class="string">"(?!r)(?P&lt;name&gt;\w+\.\w+)"</span>).findall(s))</span><br><span class="line"><span class="comment"># output&gt; ['Mr.Gumby']</span></span><br></pre></td></tr></table></figure>
<hr>
<p><em>To my family,with love</em><br>
<em>To my friend,with encourage</em><br>
<em>To my teacher,with gratitude</em></p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    

</footer>



        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']],
                            displayMath: [ ['$$','$$'], ['\[','\]'] ]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
